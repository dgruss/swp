\chapter{Semantik von Programmiersprachen}
\ifthenelse{\boolean{long}}{}{\begin{comment}}
Im ersten Kapitel haben wir uns damit beschäftigt wie ein Wort (Programm) einer Sprache eindeutig geparst werden kann.
Die Wörter (Programme) haben jedoch noch keine Bedeutung. Wir wollen uns nun damit beschäftigen
Sprachen eine Bedeutung zu geben und Sprachen anhand der Bedeutung der Wörter 
zu unterscheiden. Im Kontext der Semantik verwenden wir vermehrt den Begriff ``Programm einer Programmiersprache'' anstatt ``Wort einer Sprache''.

Im zweiten Kapitel betrachten wir nur noch syntaktisch korrekte Eingaben, d.h. wir betrachten den Fall nachdem der Parser bereits
entschieden hat, dass eine Eingabe ein syntaktisch gültiges Programm ist.

Wir teilen dazu Sprachen hauptsächlich in funktionale, imperative und logische Sprachen.
Zu jedem dieser drei Sprachparadigmen werden wir Sprachen konstruieren und deren
Semantik definieren.

Sowohl für die Definition der Semantik als auch für die Interpretation eines konkreten Programms
in einer Sprache, werden wir mathematische Funktionen definieren: die Interpretationsfunktion sowie weitere Hilfsfunktionen.
Diese mathematische Definition wird es uns erlauben die Korrektheit unserer Programme
zu beweisen.

Um Syntax und Semantik zu unterscheiden werden wir Programme einer Sprache wie bisher unterstreichen.
Die Beschreibung der Semantik ist kein Programm und wird daher auch keinesfalls unterstrichen.

\begin{bsp}
Was drückt der Ausdruck \u{a = b + c} aus? (vgl. Vorlesungsskriptum Seite 42)

Es gibt einige mögliche Interpretationen, hier eine Auswahl davon:
\begin{enumerate}
\item Imperative Interpretation: Eine Zuweisung wie in $C$. \u{a} hat nach der Ausführung des Ausdrucks den Wert der Summe der Werte von \u{b} und \u{c}.
Andere Variante: Der Wert von \u{a} ist nach der Zuweisung die Zeichenfolge \u{b + c}.
\item Funktionale Interpretation: Eine Funktion \u{a} wird mit den 4 Parametern \u{= b + c} aufgerufen.
\item Logische Interpretation: Ein logischer Ausdruck, beispielsweise ist der Ausdruck Wahr wenn der Wert von \u{a} gleich der Summe der Werte von \u{b} und \u{c} ist.
Andere Variante: Der Wert von 2 der 3 Variablen ist bekannt, der Wert der 3. Variable wird so festgelegt.
\end{enumerate}
Wir sehen anhand dieses Beispiels dass es wichtig ist exakt zu definieren wie ein Ausdruck
zu interpretieren ist.
\end{bsp}
\ifthenelse{\boolean{long}}{}{\end{comment}}
In funktionalen Programmiersprachen besteht jedes Programm aus einer oder mehreren
Funktionen.
\begin{defn}[Funktion]\label{defn:Funktion}
Eine Funktion ist eine Relation zwischen einer Menge $A$ und einer Menge $B$.
Jedem Element aus der Menge $A$ wird genau ein Element der Menge $B$ zugeordnet.
Das heißt: Für jeden möglichen Eingabewert gibt es genau einen Ausgabewert.
\end{defn}

\section{Sprache $\mathcal{A}$ - einfache arithmetische Ausdrücke}
Arithmetische Ausdrücke sind Funktionen. Wir können beispielsweise die Funktionen
Addition, Subtraktion und Multiplikation von zwei Zahlen in $\R$ definieren mit einem
Eingabewert in $\R \times \R$ und einen Ausgabewert in $\R$. Auch die Division
können wir als Funktion definieren von $\R \times \R \setminus \gbr{0}$ (Division durch $0$ schließen
wir damit aus, da die Division in diesem Fall nicht als Funktion definiert ist) auf Ausgabewerte in $\R$.

\begin{defn}
Die Sprache $\mathcal{A}$ definieren wir mit Alphabet $\Sigma=\gbr{\u{0},\ldots,\u{9},\u{(},\u{)},\u{+}}$.
Zwecks Einfachheit definieren wir Ziffern (D, digits) und Zahlen:
\begin{itemize}
\item $\mathcal{A}_D = \gbr{\u{0},\ldots,\u{9}}$
\item ZAHL $= (\mathcal{A}_D \setminus \gbr{\u{0}} \mathcal{A}_D^*) \cup \gbr{\u{0}}$
\end{itemize}
Wir definieren die Sprache $A$ nun nicht mehr über eine Grammatik sondern durch eine induktive Beschreibung (Basisfall und allgemeine Fälle):
\begin{enumerate}
\item ZAHL$\subset \mathcal{A}$
\item Wenn $x,y \in \mathcal{A}$, dann ist auch $\u{(} x \u{)} \u{+} \u{(} y \u{)} \in \mathcal{A}$.
\end{enumerate}
\end{defn}
An dieser Stelle sei noch einmal darauf hingewiesen dass wir $x,y$ nicht unterstreichen dürfen, da sie keine Sprachelemente sind sondern
Platzhalter, mathematisch würde man sie auch als Variablen bezeichnen.
\ifthenelse{\boolean{long}}{}{\begin{comment}}
Wir wollen nun mit unserer Sprache $\mathcal{A}$ Ausdrücke berechnen können.
Dazu definieren wir eines unserer mächtigsten Werkzeuge im zweiten Kapitel:
Die Interpretationsfunktion $I$ (auch genannt Semantikfunktion).
Man kann sich diese Funktion vorstellen wie einen Interpreter einer Scriptsprache:
Wir geben ein Programm ein und führen es aus, abhängig vom aktuellen Zustand liefert
uns der Interpreter ein Ergebnis zurück.
Genau so soll unsere Interpretationsfunktion arbeiten.
Wir erwarten einen Eingabewert aus $\mathcal{A}$ und bilden auf $\N_0$ ab, d.h. geben
einen Wert aus $\N_0$ zurück.
Genau wie die Syntax werden wir nun die Semantik induktiv durch die Interpretationsfunktion definieren.
\ifthenelse{\boolean{long}}{}{\end{comment}}
\begin{defn}
Die Semantik der Sprache $\mathcal{A}$ definieren wir durch:
\begin{enumerate}
\item $I_{\mathcal{A}}(x) = \sbr{x}$ wenn $x \in \mathcal{A}_N$. $x$ ist dabei eine Zeichenkette im Programm, $\sbr{x}$ die
entsprechende Repräsentation in $\N_0$.
\item $I_{\mathcal{A}}(\u{(}x\u{)+(}y\u{)})=I_{\mathcal{A}}(x) + I_{\mathcal{A}}(y)$ wenn $x,y \in \mathcal{A}$.
\end{enumerate}
\end{defn}
\ifthenelse{\boolean{long}}{}{\begin{comment}}
\begin{bsp}
Das Programm $\u{((10)+(9))+(3)}$ (vgl. Vorlesungsskriptum Seite 45) können wir wie folgt interpretieren:
\begin{align*}
I_{\mathcal{A}}(\u{((10)+(9))+(3)}) &= I_{\mathcal{A}}(\u{(10)+(9)}) + I_{\mathcal{A}}(\u{3}) \tag{entsprechend 2. Fall der Definition} \\
                      &= I_{\mathcal{A}}(\u{10}) + I_{\mathcal{A}}(\u{9}) + 3 \tag{beim $\u{3}$ nun der 1. Fall der Definition} \\
                      &= 10 + 9 + 3 = 22
\end{align*}
\end{bsp}
Auch hier sehen wir wieder deutlich die Unterscheidung zwischen Zeichenketten im Programmcode (unterstrichen) und den Werten
auf der semantischen Ebene (nicht unterstrichen). Um den Unterschied weiter zu verdeutlichen
definieren wir nun die Sprache der einfachen arithmetischen Ausdrücke von Binärzahlen $\mathcal{B}$.
\begin{defn}
Die Sprache $\mathcal{B}$ definieren wir mit Alphabet $\Sigma=\gbr{\u{0},\u{1},\u{(},\u{)},\u{+}}$.
\begin{enumerate}
\item $(\u{1} \gbr{\u{0},\u{1}}^*) \cup \gbr{\u{0}} \subset \mathcal{B}$
\item Wenn $x,y \in \mathcal{B}$, dann ist auch $\u{(} x \u{)} \u{+} \u{(} y \u{)} \in \mathcal{B}$.
\end{enumerate}
Die Semantik der Sprache $\mathcal{B}$ definieren wir durch:
\begin{enumerate}
\item $I_{\mathcal{B}}(x) = \sbr{x}$ wenn $x \in \mathcal{B}_N$. $\sbr{x} \in \N_0$ ist nun die
durch die Binärzahl (exakt: die Binärziffernfolge) dargestellte Zahl auf semantischer Ebene, in diesem Fall also im mathematischen Sinne.
\item $I(\u{(}x\u{)+(}y\u{)})=I(x) + I(y)$ wenn $x,y \in \mathcal{B}$.
\end{enumerate}
\end{defn}
\begin{bsp}
$I(\u{1001})=9$ aber $\u{1001}\neq 9$.

Betrachten wir das Beispiel wie zuvor, nun in Binärdarstellung $\u{((1010)+(1001))+(11)}$: 
\begin{align*}
I_{\mathcal{B}}(\u{((1010)+(1001))+(11)}) &= I_{\mathcal{B}}(\u{(1010)+(1001)}) + I_{\mathcal{B}}(\u{11})\\
                      &= I_{\mathcal{B}}(\u{1010}) + I_{\mathcal{B}}(\u{1001}) + 3\\
                      &= 10 + 9 + 3 = 22
\end{align*}
\end{bsp}

Wir versuchen nun der Sprache $\mathcal{A}$ eine zweite Funktion, die Multiplikation hinzuzufügen.
\begin{defn}
Die Sprache $\mathcal{C}$ ist definiert durch:
\begin{enumerate}
\item ZAHL$\subset \mathcal{C}$
\item $\u{(} x \u{)} \u{+} \u{(} y \u{)} \in \mathcal{C}$, wenn $x,y \in \mathcal{C}$.
\item $\u{(} x \u{)} \u{*} \u{(} y \u{)} \in \mathcal{C}$, wenn $x,y \in \mathcal{C}$.
\end{enumerate}
Die Semantik der Sprache $\mathcal{C}$ definieren wir durch:
\begin{enumerate}
\item $I_{\mathcal{C}}(x) = \sbr{x}$ wenn $x \in \mathcal{C}_N$.
\item $I_{\mathcal{C}}(\u{(}x\u{)*(}y\u{)})=I_{\mathcal{C}}(x) \cdot I_{\mathcal{C}}(y)$ wenn $x,y \in \mathcal{A}$.
\item $I_{\mathcal{C}}(\u{(}x\u{)+(}y\u{)})=I_{\mathcal{C}}(x) + I_{\mathcal{C}}(y)$ wenn $x,y \in \mathcal{A}$.
\end{enumerate}
\end{defn}
Mit dieser Definition ist $I_{\mathcal{C}}$ keine Funktion.

\begin{beweis}
Laut Definition~\ref{defn:Funktion} ist eine Relation eine Funktion wenn es für jeden möglichen Eingabewert genau einen Ausgabewert gibt.

Möchte man eine Aussage über ``alle'' Werte bzw. ``jeden'' Wert widerlegen so gestaltet sich ein Beweis oft relativ einfach. In so einem
Fall müssen wir nur ein Gegenbeispiel finden, denn dann gilt die Aussage offensichtlich nicht für alle Werte, wir haben ja einen gefunden
für den es nicht gilt. Diese Beweistechnik nennt man ``Beweis durch Widerspruch''.

Wir werden nun zeigen dass $I_{\mathcal{C}}$ für das Programm \u{1+2*3} verschiedene Interpretationsmöglichkeiten zulässt da nicht festgelegt
ist ob der 2. oder 3. Fall der Definition die höhere Priorität hat.
\begin{align*}
I_{\mathcal{C}}(\u{1+2*3}) &= I_{\mathcal{C}}(\u{1+2}) \cdot I_{\mathcal{C}}(\u{3}) \tag{2. Fall der Definition} \\
&= (I_{\mathcal{C}}(\u{1}) + I_{\mathcal{C}}(\u{2})) \cdot 3 \tag{3. Fall der Definition} \\
&= (1+2) \cdot 3 = 3 \cdot 3 = 9 \\
I_{\mathcal{C}}(\u{1+2*3}) &= I_{\mathcal{C}}(\u{1}) \cdot I_{\mathcal{C}}(\u{2*3}) \tag{3. Fall der Definition} \\
&= 1 + (I_{\mathcal{C}}(\u{2}) \cdot I_{\mathcal{C}}(\u{3})) \tag{2. Fall der Definition} \\
&= 1 + (2 \cdot 3) = 1 + 6 = 7 \neq 9
\end{align*}
Wir haben gezeigt dass für einen Eingabewert 2 unterschiedliche Ausgabewerte möglich sind.
Folglich gibt es nicht für \u{jeden} Eingabewert \u{genau einen} Ausgabewert, daher kann $I_{\mathcal{C}}$ keine Funktion sein. \hfill $\Box$
\end{beweis}
Wir müssten also die Interpretationsfunktion $I_{\mathcal{C}}$ anders definieren. Eine Lösung wäre beispielsweise zu definieren dass der 3. Fall der Interpretationsfunktion
nur angewendet werden darf wenn in den beiden Operanden $x$ und $y$ kein $\u{*}$ vorkommt.
\ifthenelse{\boolean{long}}{}{\end{comment}}
\section{Sprache $\mathcal{VA}$ - arithmetische Ausdrücke mit Variablen}
Wir erweitern die Sprache $\mathcal{A}$ durch Variablen und schaffen so eine mächtigere Sprache $\mathcal{VA}$.
Um mit Variablen umgehen zu können brauchen wir nun einerseits eine Menge zulässiger
Variablennamen und andererseits eine Funktion die von Variablennamen auf eine Wertemenge der semantischen Ebene (z.B. $\N_0$) abbildet.
Die Menge der zulässigen Variablennamen nennen wir IVS (Individuenvariablensymbole).
\begin{defn}
Zwecks Einfachheit erlauben wir nur wenige Variablennamen und definieren daher
\[\text{IVS} = \gbr{\u{a},\u{b},\ldots,\u{z}} \cup \gbr{\u{x1},\u{x2},\ldots}.\]
\end{defn}
Die Funktion die von Variablennamen auf eine Wertemenge abbildet nennen wir $\omega$-Environment, (Variablen-)Umgebung.
Man kann sich diese Funktion auch als Tabelle vorstellen bzw. in einem Interpreter als Tabelle implementieren.
\begin{defn}
Die Menge aller Environments sei
\[\text{ENV} = \bigcup_{x \in \text{IVS},y \in \Lambda} \gbr{(x,y)},\]
das heißt, die Vereinigung über alle Tupel Variablenname $x \in \text{IVS}$ und Wert auf semantischer Ebene $y \in \Lambda$.
\end{defn}
Für die Sprache $\mathcal{VA}$ ist $\Lambda=\N_0$.
\begin{defn}
Die Syntax der Sprache $\mathcal{VA}$ ist definiert durch:
\begin{enumerate}
\item ZAHL$\subset \mathcal{VA}$
\item IVS$\subset \mathcal{VA}$
\item $\u{(} x \u{)} \u{+} \u{(} y \u{)} \in \mathcal{C}$, wenn $x,y \in \mathcal{VA}$.
\end{enumerate}
\end{defn}
Die Interpretation eines Programms hängt nun nicht mehr allein vom Programm selbst ab,
sondern auch von den Werten der Variablen im $\omega$-Environment.
\begin{defn}
Die Interpretationsfunktion $I_{\mathcal{VA}}: \text{ENV}\times\mathcal{VA} \to \Lambda$
weist jedem Tupel aus Environment und Programm einen Wert in $\Lambda$ zu.
\begin{enumerate}
\item $I_{\mathcal{VA}}(\omega,k) = \sbr{k}$ wenn $k \in \text{ZAHL}$, $\omega \in \text{ENV}$.
\item $I_{\mathcal{VA}}(\omega,v) = \omega(v)$ wenn $vk \in \text{IVS}$, $\omega \in \text{ENV}$.
\item $I_{\mathcal{VA}}(\u{(}x\u{)+(}y\u{)})=I_{\mathcal{VA}}(\omega,x) + I_{\mathcal{VA}}(\omega,y)$ wenn $x,y \in \mathcal{VA}$, $\omega \in \text{ENV}$.
\end{enumerate}
\end{defn}
\ifthenelse{\boolean{long}}{}{\begin{comment}}
\begin{bsp}
Gegeben Sei das Environment $\omega(\u{x})=0$, $\omega(\u{y})=1$, $\omega(\u{z})=2$.
Interpretieren Sie das Programm $\u{(((x)+(2))+(y))+(z)}$.
\begin{align*}
I_{\mathcal{VA}}(\omega,\u{(((x)+(2))+(y))+(z)}) &= I_{\mathcal{VA}}(\omega,\u{((x)+(2))+(y)}) + I_{\mathcal{VA}}(\omega,\u{z}) \\
&= I_{\mathcal{VA}}(\omega,\u{(x)+(2)}) + I_{\mathcal{VA}}(\omega,\u{y}) + \omega(\u{z}) \\
&= I_{\mathcal{VA}}(\omega,\u{x}) + I_{\mathcal{VA}}(\omega,\u{2}) + \omega(\u{y}) + 2 \\
&= \omega(\u{x}) + 2 + 1 + 2 \\
&= 0 + 2 + 1 + 2 = 5
\end{align*}
Beachten Sie auch, dass nach wie vor $I_{\mathcal{VA}}(\omega,\u{2})=2$.
Es ist ein bei den Übungen weit verbreiteter Fehler $I_{\mathcal{VA}}(\omega,\u{2}) = \omega(\u{2})$ zu schreiben. Die Interpretationsfunktion wurde so nicht definiert und
außerdem ist $\u{2}$ auch kein gültiger Variablenname.
\end{bsp}
\ifthenelse{\boolean{long}}{}{\end{comment}}

\section{Datentypen}
Bisher haben wir eine Sprache nur für einen Datentypen definiert. Dieser war implizit in der
Definition der Sprache drin (beispielsweise die natürlichen Zahlen). Derartige Definitionen
erlauben kein Ersetzen des Datentyps ohne die Definition der Sprache wesentlich zu überarbeiten.
Da wir dies aber häufig wollen werden wir nun zuerst Datentypen auf der semantischen Ebene
und anschließend die Repräsentation von Datentypen auf der syntaktischen Ebene definieren.
\begin{defn}[Datentyp]
Ein Datentyp ist ein Tupel $\Psi=\rbr{A,F,P,C}$ mit
\begin{itemize}
\item $A$: Grundmenge (Wertebereich)
\item $F$: Menge von Funktionen $f_i: A^{k_i} \to A^{l_i}$.

$f_i$ ist die $i$-te Funktion in der Menge, $k_i$ die Dimension vom Urbild (Dimension des Inputs, Anzahl der Funktionsargumente) und $l_i$
die Dimension vom Bild der $i$-ten Funktion (Dimension des Outputs, Anzahl der Funktionsrückgabewerte).
\item $P$: Menge von Prädikaten $p_i: A^{k_i} \to \gbr{T,F}$.

$p_i$ ist die $i$-te Funktion in der Menge und $k_i$ die Dimension vom Urbild (Dimension des Inputs, Anzahl der Funktionsargumente) der $i$-ten Funktion.
\item $C$: Menge von Konstanten $c_i$ wobei $c \subseteq A$.
\end{itemize}
Die Mengen $F^{\Sigma}$, $P^{\Sigma}$ und $C^{\Sigma}$ enthalten die entsprechenden Symbole für die syntaktische Repräsentation:
\begin{itemize}
\item Funktionssymbole $F^{\Sigma}$: je ein Symbol $f^{\Sigma}_i$ (z.B. Name der Funktion) für jede Funktion $f_i$
\item Prädikatensymbole $P^{\Sigma}$: je ein Symbol $p^{\Sigma}_i$ (z.B. Name des Prädikats) für jedes Prädikat $p_i$
\item Konstantensymbol $C^{\Sigma}$: je ein Symbol $c^{\Sigma}_i$ (z.B. ausgeschriebene Form der Konstante) für jede Konstante $c_i$
\end{itemize}
\end{defn}

Konstanten sind eigentlich nur spezielle Funktionen ($0$ Argumente) und wir unterscheiden nur zwecks Übersicht.
\begin{bsp}
Definieren Sie den Datentyp Integer mit Funktionen für Addition, Subtraktion und Multiplikation sowie Prädikaten für
``kleiner'' und Gleichheit.

\textit{Lösung:}
Im Fall der Integer ist die Definition der Funktionen und Prädikate trivial, da
alle Funktionen und Prädikate durch die entsprechenden Operationen auf den ganzen Zahlen $\Z$ definiert sind.
Daher genügt es zu definieren welche Funktion welcher Operation entspricht.
\begin{itemize}\label{defn:integer}
\item Grundmenge $A=\Z$
\item Funktionen $f_1: +$, $f_2: -$, $f_3: *$

Die Funktionen $+, -, *$ sind auf $\Z$ definiert.
Auf der syntaktischen Ebene definieren wir: $f^{\Sigma}_1: \u{\tplus}$, $f^{\Sigma}_2: \u{\tminus}$, $f^{\Sigma}_3: \u{\tmult}$.
\item Prädikate $p_1: <$, $p_2: =$

Die Prädikate $<, =$ sind auf $\Z$ definiert.
Syntaktische Ebene: $p^{\Sigma}_1: \u{\tlt}$, $p^{\Sigma}_2: \u{\teq}$.
\item Konstanten $c_1: 0$, $c_2: 1$

Syntaktische Ebene: $c^{\Sigma}_1: \u{\tnull}$, $c^{\Sigma}_2: \u{\teins}$.
\end{itemize}
Hinzunahme von Division ist problematisch $/$ da das Ergebnis nicht unbedingt $\in A$ ist.
\end{bsp}
Wir können bei der Definition eines Datentyps oft (z.B. bei den verschiedenen Datentypen für Zahlen) auf bekannte algebraische Strukturen (Halbgruppen, etc.) zurückgreifen.
\ifthenelse{\boolean{long}}{}{\begin{comment}}
\begin{bsp}
Definieren Sie den Datentyp String mit der Funktion Konkatenation und dem Prädikat ``Präfix''.

\textit{Lösung:} Hier können wir nun nicht mehr auf eine vorhandene mathematische Definition
zurückgreifen.
\begin{itemize}
\item Grundmenge $A=V^*$ mit $V$ einem endlichen Alphabet $\gbr{v_1,\ldots,v_n}$ (z.B. dem ASCII-Alphabet).
\item Funktionen
\begin{enumerate}
\item $f_1: \circ$ (Konkatenation)
\begin{itemize}
\item Wenn $x \in V^*$ ist, dann ist $x \circ \varepsilon = x$
\item Wenn $x \in V^*$ und $a \in V$ ist, dann ist $x \circ a = xa$
\item Wenn $x,y \in V^*$ und $a \in V$ ist, dann ist $x \circ (y \circ a) = (x \circ y) \circ a$
\end{itemize}
\end{enumerate}
\item Prädikate
\begin{enumerate}
\item $p_1: <<$ (Präfix)
\begin{itemize}
\item Wenn $x \in V^*$ ist, dann ist $\varepsilon << x$
\item Wenn $x \in V^*$ ist, dann ist $x << x$
\item Wenn $x$ Präfix von $y$ ist, dann ist $x$ auch Präfix von $y \circ z$
($(x << y) \ra (x << (y \circ z))$).
\end{itemize}
\end{enumerate}
\item Konstanten $c_i: v_i$, $c_{n+1}: \varepsilon$ (eine Konstante für jeden Buchstaben des Alphabets und $\varepsilon$ für den Leerstring).
\end{itemize}
Die syntaktische Ebene überlassen wir dem Leser.
\end{bsp}
\ifthenelse{\boolean{long}}{}{\end{comment}}
\ifthenelse{\boolean{long}}{}{\begin{comment}}
\begin{bsp}
Definieren Sie den Datentyp des binären Stacks mit Funktionen um Elemente auf den Stack zu legen oder herunterzunehmen, sowie
Prädikaten zur Überprüfung des obersten Elementes.

\textit{Lösung:}
\begin{itemize}
\item Grundmenge $A=\gbr{0,1}^* \cup \gbr{\varepsilon}$, d.h. Ziffernfolgen aus $0$ und $1$ oder $\varepsilon$ (leerer Stack).
\item Funktionen
\begin{enumerate}
\item $f_1: \text{add0}$ liefert den Stack mit einer $0$ daraufgelegt.
\begin{itemize}
\item $\text{add0}(\varepsilon)=0$
\item $\text{add0}(x)=0x$ (mit $x \neq \varepsilon$)
\end{itemize}
\item $f_2: \text{add1}$ liefert den Stack mit einer $1$ daraufgelegt.
\begin{itemize}
\item $\text{add1}(\varepsilon)=1$
\item $\text{add1}(x)=1x$ (mit $x \neq \varepsilon$)
\end{itemize}
\item $f_3: \text{sub}$ liefert den Stack ohne das oberste Element.
\begin{itemize}
\item $\text{sub}(\varepsilon)=\varepsilon$
\item $\text{sub}(ax)=x$ (mit $a \neq \varepsilon$)
\end{itemize}
\end{enumerate}
\item Prädikate
\begin{enumerate}
\item $p_1: \text{ist0?}$ testet ob das oberste Element $0$ ist.
\begin{itemize}
\item $\text{ist0?}(x) \Lra \exists z : x = 0z$
\end{itemize}
\item $p_2: \text{ist1?}$ testet ob das oberste Element $1$ ist.
\begin{itemize}
\item $\text{ist1?}(x) \Lra \exists z : x = 1z$
\end{itemize}
\item $p_3: \text{istLeer?}$ testet ob das oberste Element $\varepsilon$ ist.
\begin{itemize}
\item $\text{istLeer?}(x) \Lra x = \varepsilon$
\end{itemize}
\end{enumerate}
\item Konstanten $c_1: \varepsilon$.
\end{itemize}
Auf der syntaktischen Ebene werden die gleichen Bezeichnungen wie auf der semantischen Ebene verwendet.
\end{bsp}

\begin{bsp}
Berechnen Sie den Ausdruck $\text{add0}(\text{add1}(\text{sub}(011)))$ im Datentyp des binären Stacks.

\textit{Lösung:}
\begin{align*}
&\quad \text{add0}(\text{add1}(\text{sub}(011))) \\
&= \text{add0}(\text{add1}(11)) \\
&= \text{add0}(111) \\
&= 0111
\end{align*}
\begin{align*}
\text{ist0?}(0111)&=T \\
\text{ist1?}(0111)&=F \\
\text{istLeer?}(0111)&=F
\end{align*}
\end{bsp}
\ifthenelse{\boolean{long}}{}{\end{comment}}

\section{Sprache der Terme $\mathcal{T}$}
Wir müssen nun um den Datentyp verwenden zu können eine grundlegende Sprache 
definieren die diesen Datentyp verwendet. Auf dieser Sprache können dann weitere Sprachen
aufgebaut werden.
\begin{defn}[Sprache der Terme $\mathcal{T}$]
Sei $\Psi=\rbr{A,F,P,C}$ ein Datentyp.
Das Alphabet $\Sigma$ ist dann eine Vereinigung aus den Mengen der
\begin{itemize}
\item IVS (Individuenvariablensymbole)
\item Funktionssymbole $F^{\Sigma}$
\item Prädikatensymbole $P^{\Sigma}$
\item Konstantensymbol $C^{\Sigma}$
\item $\u{(}$,$\u{)}$ und $\u{,}$
\item Sondersymbole (Keywords): \u{if}, \u{then}, \u{else}, \u{begin}, \u{end}, $\ldots$
\end{itemize}
Die Syntax von $\mathcal{T} \subseteq \Sigma$ über einem beliebigen Datentypen ist dann definiert durch:
\begin{enumerate}
\item $C^{\Sigma} \subseteq \mathcal{T}$, d.h. Konstantensymbole sind Terme
\item $\text{IVS} \subseteq \mathcal{T}$, d.h. Individuenvariablensymbole sind Terme
\item Wenn $f^{\Sigma}_i$ ein $n$-stelliges Funktionssymbol ist und $t_1,\ldots,t_n$ Terme,
dann ist auch $f^{\Sigma}_i\u{(}t_1\u{,}\ldots\u{,}t_n\u{)}$ ein Term (Unterstreichungen beachten!).
\end{enumerate}
Die Semantik von $\mathcal{T}$ definieren wir durch die Interpretationsfunktion $I_{\mathcal{T}}: \text{ENV} \times \mathcal{T} \to A$.
\begin{enumerate}
\item $I_{\mathcal{T}}(\omega,c'_i)=c_i$ mit $c_i \in C$ (Semantik-Ebene), $c'_i \in C^{\Sigma}$ (Syntax-Ebene) und $\omega \in \text{ENV}$.
\item $I_{\mathcal{T}}(\omega,v)=\omega(v)$ mit $v \in \text{IVS}$ und $\omega \in \text{ENV}$.
\item $I_{\mathcal{T}}(\omega,f'_i\u{(}t_1\u{,}\ldots\u{,}t_n\u{)})=f_i(I_{\mathcal{T}}(\omega,t_1),\ldots,I_{\mathcal{T}}(\omega,t_n))$ mit $f_i \in F$ (Semantik-Ebene), $f'_i \in F^{\Sigma}$ (Syntax-Ebene) und $\omega \in \text{ENV}$.
\end{enumerate}
\end{defn}

\begin{bsp}
Führen Sie das Programm \u{plus(plus(x,y),plus(eins,z))} mit dem Environment $\omega(\u{x})=0$, $\omega(\u{y})=1$, $\omega(\u{z})=2$ aus.

\textit{Lösung:}
\begin{align*}
\I{T}{\omega}{\tplus\rbr{\tplus(x,y),\tplus(\teins,z)}}
&= +\rbr{\I{T}{\omega}{\tplus(x,y)},\I{T}{\omega}{\tplus(\teins,z)}} \\
&= +\rbr{+\rbr{\I{T}{\omega}{x},\I{T}{\omega}{y}},+\rbr{\I{T}{\omega}{\teins},\I{T}{\omega}{z}}} \\
&= +\rbr{+\rbr{\omega(\u{x}),\omega(\u{y})},+\rbr{1,\omega(\u{z})}} \\
&= +\rbr{+\rbr{0,1},+\rbr{1,2}} = +\rbr{1,3} = 4
\end{align*}
\end{bsp}

Laut Definition von $\mathcal{T}$ gibt es nur die Konstanten $0$ und $1$. Variablen können natürlich jeden beliebigen Wert in $\Z$ annehmen.
Es kann aber auch gezeigt werden dass alle ganzen Zahlen durch einen variablenfreien Term dargestellt werden können.
Terme sind rekursiv definiert. Die \textbf{vollständige Induktion} ist die übliche Beweistechnik für Beweise über rekursive bzw. rekursiv definierte Ausdrücke.

\begin{bsp}
Wir wollen zeigen, dass alle ganzen Zahlen durch einen variablenfreien Term dargestellt werden können.
Die \textbf{vollständige Induktion} besteht aus 3 Einzelschritten: In der \textbf{Induktionsbasis} werden ein oder mehrere Basisfälle direkt bewiesen.
In der \textbf{Induktionshypothese} wird versucht eine allgemeine Aussage (eine Hypothese) zu treffen von der angenommen wird dass sie bis zum $n$-ten Fall gilt.
Im \textbf{Induktionsschritt} gehen wir einen Schritt weiter, also in den Fall $n+1$ und versuchen diesen zu beweisen. Hier muss unbedingt auf die Induktionshypothese zurückgegriffen
werden, sonst wurde keine vollständige Induktion durchgeführt.

Um eine Induktion durchführen zu können müssen die Elemente unbedingt aufgezählt werden können (d.h. man muss eine eindeutige Reihenfolge/Sortierung für die Elemente angeben können).

Bevor wir die Induktion durchführen versuchen wir ein Muster zu erkennen.
\begin{align*}
\I{T}{\omega}{\tnull}&=0 \tag{trivial}\\
\I{T}{\omega}{\teins}&=1 \tag{trivial}\\
\I{T}{\omega}{\tplus\rbr{\teins,\teins}}&=2 \tag{eine Addition}\\
\I{T}{\omega}{\tplus\rbr{\teins,\tplus\rbr{\teins,\teins}}}&=3 \tag{verschachtelte Addition}
\end{align*}
Wir erkennen das Muster: Alle Zahlen $\in \N$ können durch rekursive Addition von 1 dargestellt werden.
Diese Rekursion kann beliebig tief werden, hat allerdings immer die gleiche Form.
Wir definieren uns einen Platzhalter $t_k$ um beliebig lange solcher Ausdrücke einfach darzustellen:
\begin{align*}
t_2 &= \u{\tplus(\teins,\teins)} \\
t_3 &= \u{\tplus(\teins,\tplus(\teins,\teins))} \\
&\vdots \\
t_{k+1} &= \u{\tplus(\teins,}t_{k}\u{)} \\
\end{align*}
$k$ entsprichtder Anzahl der $\u{\teins}$ im Ausdruck.

\begin{itemize}
\item \textbf{Induktionsbasis:}\\
In der Induktionsbasis beweisen wir einen oder mehrere Basisfälle.
Das sind in unserem Fall die beiden Konstanten sowie der Fall $t_2$:
\begin{align*}
\I{T}{\omega}{\tnull}&=0 \\
\I{T}{\omega}{\teins}&=1 \\
\Iu{T}{\omega}{t_2}&=\I{T}{\omega}{\tplus(\teins,\teins)}=2\\
\end{align*}
\item \textbf{Induktionshypothese:}\\
In der Induktionshypothese treffen wir eine Aussage über ein Element $n$ oder mehrere (evtl. alle) Elemente bis zu einem gewissen Element $n$.
In unserem Fall sagen wir dass
\begin{align*}
\Iu{T}{\omega}{t_n}&=n
\end{align*}
\item \textbf{Induktionsschritt:}\\
Im Induktionsschritt erfolgt zeigen wir nun dass unter Annahme der Korrektheit der Induktionshypothese der Beweis auch für das Element $n+1$ (also das erste Element über das wir
keine Annahme getroffen haben) erbracht werden kann. (Häufiger Fehler: Wird im Induktionsschritt die Induktionshypothese nicht verwendet so handelt es sich nicht um eine vollständige Induktion!)
Wir müssen also zeigen dass:
\begin{align*}
\Iu{T}{\omega}{t_{n+1}}&=n+1 \tag{Einsetzen von $t_{n+1}$}\\
\Iu{T}{\omega}{\u{\tplus(\teins,}t_{n}\u{)}}&=n+1 \tag{Interpretationsfunktion durchführen}\\
+\rbr{\Iu{T}{\omega}{\u{\teins}},\Iu{T}{\omega}{t_{n}}}&=n+1 \\
+\rbr{1,\Iu{T}{\omega}{t_{n}}}&=n+1
\intertext{\textbf{Unter Verwendung der Induktionshypothese (d.h. wir setzen die Induktionshypothese $\Iu{T}{\omega}{t_n}=n$ ein):}}
+\rbr{1,n}&=n+1
\end{align*}
Damit ist der Beweis erbracht.
\end{itemize}
\end{bsp}

